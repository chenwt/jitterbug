#!/usr/bin/env python

import sys
import getopt
import argparse
from GffAnnot import *


def main(argv):

    ##############START argparse version 

    parser = argparse.ArgumentParser()

    
    
    parser.add_argument("-g", "--gff", help="file in gff3 format of TEI generated by Jitterbug")
    parser.add_argument("-c", "--config", help="config file with filtering parameters, generated by Jitterbug")
    parser.add_argument("-o", "--output", help="name of output file")

    args = parser.parse_args()

    jitterbug_filter_results(args.gff, args.config, args.output)


    ############## END argparse version

    ############## START getopt version 
    
    # # get options passed at command line
    # try:
    #     opts, args = getopt.getopt(argv, "g:c:o:")
    # except getopt.GetoptError:
    #     print "jitterbug_filter_results opts wrong"
    #     sys.exit(2)


    # # cluster_size_min = 0
    # # cluster_size_max = None

    # # span_min = 0
    # # span_max = None

    # # int_size_min = 0
    # # int_size_max = None

    # # pick_consistent = None

    # outfile = None

    # config_file = None


    # for opt, arg in opts:
    #     if opt == '-g':
    #         gffFile = arg
    #     # elif opt == '-c':
    #     #     cluster_size_min = int(arg)
    #     # elif opt == '-C':
    #     #     cluster_size_max = int(arg)
    #     # elif opt == '-s':
    #     #     span_min = int(arg)
    #     # elif opt == '-S':
    #     #     span_max = int(arg)
    #     # elif opt == '-i':
    #     #     int_size_min = int(arg)
    #     # elif opt == '-I':
    #     #     int_size_max = int(arg)
    #     # elif opt == '-p':
    #     #     softclipped_min = int(arg)
    #     # elif opt == '-f':
    #     #     (min_index, max_index) = map(int() , arg.split(","))


    #     elif opt == '-c':
    #         config_file = arg
    #     elif opt == '-o':
    #         outfile = arg

   
    # # if not config_file:
    # #     criteria_dict = {}
    # #     criteria_dict.append(("cluster_size", cluster_size_min, cluster_size_max))
    # #     criteria_dict.append(("span", span_min, span_max))
    # #     criteria_dict.append(("int_size", int_size_min, int_size_max))
    # #     criteria_dict.append(("pick_consistent", min_index, max_index))
    # #     criteria_dict.append(("softclipped", softclipped_min, None))

   

    # #outfile_name = "%s.c%d_C%d_i%d_I%d_s%d_S%d_p%d_f%d%d.gff3" % (outfile, cluster_size_min, cluster_size_max, int_size_min, int_size_max, span_min, span_max, softclipped_min, min_index, max_index)
    
    # jitterbug_filter_results(gffFile, config_file, outfile)

    ################# END getopt version ####################

    





def jitterbug_filter_results(gffFile, config_file, outfile):

    criteria_dict = {}

    for line in open(config_file):
        line = line.strip()
        (tag, min_val, max_val) = line.split("\t")
        criteria_dict[tag] = (int(min_val), int(max_val))
    
    if not outfile:
        outfile = gffFile.strip(".gff3")

        for crit in ["cluster_size", "span", "int_size", "softclipped", "pick_consistent"]:
            min_val, max_val = criteria_dict[crit]
            if crit == "cluster_size":
                outfile = outfile + ".clust%d_%d" % (min_val, max_val)
            elif crit == "span":
                outfile = outfile + ".span%d_%d" % (min_val, max_val)
            elif crit == "int_size":
                outfile = outfile + ".int%d_%d" % (min_val, max_val)
            elif crit == "softclipped":
                outfile = outfile + ".soft%d_%d" % (min_val, max_val)
            elif crit == "pick_consistent":
                outfile = outfile + ".cons%d_%d" % (min_val, max_val)

        outfile = outfile + ".gff3"




    OUT_GFF_FILE_SELECTED = open(outfile ,  "w")


    num_rows = 0
    clsize =0
    consis=0
    span_c = 0
    int_size_c=0
    softclip_c=0
    IN_GFF_FILE = open(gffFile)
    total_rows =0

    for line in IN_GFF_FILE:
        
        line = line.strip()
        #ignore empty line or comment lines
        if line[0] == '#':
            continue
        if line == "":
            continue
        feature = GffAnnot(line)
        total_rows +=1

        eliminate = False
        for criteria, (min_val, max_val) in criteria_dict.items():

            if criteria == "cluster_size":
                if min_val and int(feature.tags['supporting_fwd_reads']) < min_val or int(feature.tags['supporting_rev_reads']) < min_val:
                    eliminate = True
                    clsize+=1

                if max_val and int(feature.tags['supporting_fwd_reads']) > max_val or int(feature.tags['supporting_rev_reads']) > max_val:
                    eliminate = True
                    clsize+=1

            
            elif criteria == "pick_consistent":
                element = None
                conflicting = True

                #here min_val and max_val are the min and max (inclusive) indices of the tokens of the TE names split by "_" to consider
                #print min_val
                #print max_val
                # fwd_fams = ["_".join(TE_name.split("_")[min_val:max_val+1]) for TE_name in feature.tags["Inserted_TE_tags_fwd"].split(", ")]
                # rev_fams = ["_".join(TE_name.split("_")[min_val:max_val+1]) for TE_name in feature.tags["Inserted_TE_tags_rev"].split(", ")]

                fwd_fams = feature.tags["Inserted_TE_tags_fwd"].split(", ")
                rev_fams = feature.tags["Inserted_TE_tags_rev"].split(", ")
                ##?checks for family, if both are undefined they are kept
                if fwd_fams[0] == rev_fams[0] and fwd_fams[0] == 'undefined':
                   conflicting =False
                   element = fwd_fams[0]
                   
                   
                for fwd_fam in fwd_fams:
                    fwd_fam = fwd_fam.strip()
                    if fwd_fam != "undefined" and fwd_fam in rev_fams:
                        conflicting = False
                        element = fwd_fam
                        consis+=1
                        #print "breaking"
                        break
                #print "broke"
                if conflicting:
                    eliminate = True

                if element:
                    superfam_tag = "; predicted_superfam=%s" % (element)
                    line += superfam_tag

            elif criteria == "span":
                if min_val and int(feature.tags['fwd_cluster_span']) < min_val or int(feature.tags['rev_cluster_span']) < min_val:
                    eliminate = True
                    span_c+=1
                if max_val and int(feature.tags['fwd_cluster_span']) > max_val or int(feature.tags['rev_cluster_span']) > max_val:
                    eliminate = True
                    span_c+=1

            elif criteria == "int_size":
                if min_val and feature.length < min_val:
                    eliminate = True
                    int_size_c+=1
                if max_val and feature.length > max_val:
                    eliminate = True
                    int_size_c+=1
                    
            elif criteria == "softclipped":
                if min_val and int(feature.tags['softclipped_support']) < min_val:
                    eliminate = True
                    softclip_c+=1
                if max_val and int(feature.tags['softclipped_support']) > max_val:
                    eliminate = True
                    softclip_c+=1

            
            
                    
        if eliminate:
            continue


        OUT_GFF_FILE_SELECTED.write(line + "\n")
        
        num_rows += 1

    print 'Total rows = %d'%total_rows
    print 'Passed rows =%d \n'%num_rows
    print 'Description of the non passed rows:'
    print 'Problems with softclip support:\t' + str(softclip_c)
    print 'Wrong interval size:\t' + str(int_size_c)
    print 'Wrong span size:\t' +    str(span_c)
    print 'Inconsistency of TE family FWD and REV:\t' + str(consis)
    print 'Wrong cluster size:\t' + str(clsize)

    OUT_GFF_FILE_SELECTED.close()
    


if __name__ == "__main__":
    main(sys.argv[1:])
